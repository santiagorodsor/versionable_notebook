Jupyter notebooks python versionable
-----
Author: @santiagorodsor

# What is this?
This bunch of files where created adhoc in a single project in order to work in a team without smashing common clases in Data Analysis process. This may happen despite correct cvs usage, due to fast development team work.

Main focus is to ease common files working, easy function importing and keep creating.

Just python, tested on 2 and 3, by now.

# It is full developed?
It accomplish each feature it promises, but it is really early version and further cleansing and feaures could and should be added. Ideally as jupyter extension, please help here!! 

# Fast view
## Features
- Easy cell as file content inclusion and ignoring from plain jupyter cells.
- Easy file versioning.
- Easy version loading without kernel restarting.

## Folder structure
	/project/  
		- data/  
		- develop/  
			- versionable.py
			- backend_versionable.py (autogenerated)
			- Backend_versionable_v_1.py (autogenerated)
		- src/  
		- images/
	
## Organizaci√≥n de carpetas
`develop` folder has data analysis notebook with well defined purposes. Some times, single notebooks results on function to be shared among the project meanwhile its updated. 

- feature engineering
- data cleaning
- dynamic dataset segment
- dynamic outliers definition

So, these functions should be treated as "back" component, this could be easily featured by 3 components.

- **notebook status variable** `write_to_file`: Indicates whether notebook is being saved to a file or executed.
- **name** `versionable_name`:  Name of versionable object
- **version** `versionable_version`: Current back version being edited.
	It is thought with format `v_#`, so if no specific number is given when loading, it loads greater version found file with this format (see later).
	It is not strictly version format,  only requires string type version

- **ipython magic functions**:  
	Any cell to be taked in care should add specific magic function in it. These are new magic functions to be added.
	- **writefile\_versionable\_write**:  
It starts to write in file with current cell content and clean it if exists
	- **writefile\_versionable\_add**:  
Adds current cell content to versionable file.
	- **writefile\_versionable\_ignore**:  
Makes this cell content ignorable in write status.

Given it is time to create a version of the file, `write_to_file` is set to **True** and click run button to run all cells. To keep testing and/or editing set again `write_to_file` to **False**.

## Version creation
Way of work is as easy as start working normally in a note book, then add the top cells, as in demo, versionable features and custom magic functions cell.
Then, add magic function call to selected cells.

In order to create a new version an left current as old or apart but still reachable, just change version, and run all cells. A new file tagged with new version will be created.

## Load created files on the fly
In `develop` folder, you can find `versionable.py` and will be autogenerated (avoid editing) `backend_<name api>.py` and `Backend_<name api>_<version>.py` created and versioned along it is used..

From another notebook, these can be loaded as:

	from backend_<name api> import Backend_<name api>

An preferred version can be loaded as follows, and stored in some variable as:

	api = Backend_<name api>([<version>])

`version` is optional so it would search for greater version.
Content of imports is refreshed while running so it is no more necessary to restart kernel anymore to add any new changes on "back versionable" files. Believe me, this will make the point :)
As well, diferent versions of same back can be loaded in diferent variables

	api1 = Backend_<nombre api>(1) 
	api2 = Backend_<nombre api>(2)

# Work ahead
- Add files into src folder to keep everything tidy
- Add ipython magic function definitions to versionable file, in order to simplify "versioned" notebooks.
- Nbextensions integration.
- adapt to other jupyter available languages.
- less headaches with common "backend files updating"
 