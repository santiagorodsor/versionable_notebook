Jupyter notebooks python versionable
-----
Author: @santiagorodsor

# What is this?
This asset project was created adhoc in a single project to avoid shared backend files crunching in Data Analysis process. This may happen despite correct cvs usage, due to fast development team work.

Main focus is to ease share files working, easy functions importing and focus on analysis.

Just for python, tested on 2 and 3.

# It is fully developed?
It accomplish each feature it promises, with a really early version, so further cleansing and feaures could be added. (Ideally as jupyter extension, please help here!!)  

# Fast view
## Features
- Easy cell as file content inclusion and ignoring from plain jupyter cells.
- Easy file versioning.
- Easy version loading without kernel restarting.

## Folder structure
	/project/  
		- data/  
		- develop/  
			- versionable.py
			- versionable_magic_functions.py
			- backend_versionable.py (autogenerated)
			- Backend_versionable_v_1.py (autogenerated)
		- src/  
		- images/
	
## Organizaci√≥n de carpetas
`develop` folder has data analysis notebook with well defined purposes. Some times, single notebooks results on function to be shared among the project meanwhile its updated. 

- feature engineering
- data cleaning
- dynamic dataset segment
- dynamic outliers definition

So, these functions should be treated as "back" component, this could be easily featured by 3 components.

- **notebook status variable** `write_to_file`: Indicates whether notebook is being saved to a file or executed.
- **name** `versionable_name`:  Name of versionable object
- **version** `versionable_version`: Current back version being edited.
	Files format are `#.py`, so if no specific number is given when loading, it finds and load greatest version(see later).
	It is not strictly version format, only requires string type version

- **ipython magic functions**:  
	Any cell to be taked in care should add specific magic function in it. These are new magic functions to be added.
	- **writefile\_versionable\_write**:  
It starts to write in file with current cell content and clean it if exists
	- **writefile\_versionable\_add**:  
Adds current cell content to versionable file.
	- **writefile\_versionable\_ignore**:  
Makes this cell content ignorable in write status.

Given it is time to create a version of the file, `write_to_file` is set to **True** and click run button to run all cells. To keep testing and/or editing set again `write_to_file` to **False**.

## Version creation
Way of work is as easy as start working normally in a note book, then add the top cell as in demo: versionable features, buildup and load magic functions.
Then, add magic function call to selected cells.

In order to create a new version an left current as old or apart but still reachable, just change version, and run all cells. A new file tagged with new version will be created.

## Load created files on the fly
In `develop` folder, you can find `versionable.py` and will be autogenerated (avoid editing) `backend_<name api>.py` and `Backend_<name api>_<version>.py` created and versioned along it is used.

From another notebook, these can be loaded as:

	from backend_<name api> import Backend_<name api>

A preferred version can be loaded as follows, and stored in some variable as:

	api = Backend_<name api>([<version>])

`version` is optional so it would search for greater version.  
Content of imports is refreshed while running so it is no necessary to restart kernel anymore to add any new changes on "back versionable" files. Believe me, this will make the point :)
As well diferent versions of same back can be loaded in diferent variables, indeed greatest version automatically found.

	api1 = Backend_<nombre api>(1) 
	api2 = Backend_<nombre api>(2)
	api = Backend_<nombre api>()
	api_testing = Backend_<nombre api>("testing")
# Case of use
- Use it to store SQL queries, or dynamic segmentations  
- Shared easy data segmentation
- Shared models
- Shared metrics
- Shared plot functions

From a higher point of view this way of work provides easy access to make use of diferent combinations of feature engineering, data cleaning, data segmentation, ...

# Work ahead
- Add files into src folder to keep everything tidy
- Add ipython magic function definitions to versionable file, in order to simplify "versioned" notebooks.
- Nbextensions integration.
- adapt to other jupyter available languages.
- less headaches with common "backend files sharing"
 